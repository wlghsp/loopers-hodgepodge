# 5주차 과제 진행 계획

> 실제 트래픽에서 자주 발생하는 **조회 병목 문제**를 해결하는 방법을 실습

---

## 📊 현재 프로젝트 상태 분석

### ✅ 이미 완료된 것들

| 항목 | 상태 | 설명 |
|------|------|------|
| **비정규화 컬럼** | ✅ 완료 | `Product.likesCount` 컬럼 존재 |
| **좋아요 동기화** | ✅ 완료 | `increaseLikesCount()`, `decreaseLikesCount()` + 비관적 락 적용 |
| **좋아요 순 정렬** | ✅ 완료 | `ProductSortType.LIKES_DESC` 구현됨 |
| **Redis 모듈** | ⚠️ 설정만 됨 | 연결 설정은 있으나 실제 캐시 적용 없음 |

### ❌ 해야 할 것들 (AS-IS 상태로 초기화됨)

| 항목 | 상태 | 설명 |
|------|------|------|
| **상품 10만개 데이터** | ❌ 미완료 | 테스트용 대량 데이터 준비 필요 |
| **Product 테이블 인덱스** | ❌ 없음 | `brand_id`, `likes_count` 등에 인덱스 없음 |
| **Like 테이블 인덱스** | ❌ 주석처리됨 | `idx_likes_member_id`, `idx_likes_product_id` 제거 |
| **EXPLAIN 분석** | ❌ 미완료 | 인덱스 적용 전/후 비교 필요 |
| **Redis 캐시 적용** | ❌ 미완료 | 상품 목록/상세 API에 캐시 미적용 |
| **TTL/무효화 전략** | ❌ 미완료 | 캐시 전략 설계 필요 |

---

## 📋 진행 태스크 목록

### Task 1: 테스트 데이터 준비
> 상품 10만개 이상 + 다양한 분포

- [ ] 브랜드 데이터 생성 (50~100개)
- [ ] 상품 데이터 10만개 생성
  - 브랜드별 다양한 분포
  - 가격 다양하게 분포
  - 좋아요 수 다양하게 분포 (0 ~ 10,000)
- [ ] 데이터 생성 스크립트 작성 (SQL 또는 Kotlin)

---

### Task 2: 인덱스 최적화 (AS-IS → TO-BE)

#### 2-1. AS-IS 분석 (인덱스 없는 상태)
- [ ] 현재 Product 테이블 인덱스 상태 확인 (PK만 존재)
- [ ] 현재 Like 테이블 인덱스 상태 확인 (PK + UNIQUE만 존재)
- [ ] Product 쿼리 `EXPLAIN` 분석
  - 브랜드 필터 + 좋아요 순 정렬
  - 전체 상품 + 좋아요 순 정렬
- [ ] Like 쿼리 `EXPLAIN` 분석
  - 내 좋아요 목록 조회 (member_id 조건)
- [ ] 실행 시간 측정 (10만 데이터 기준)
- [ ] 스크린샷 저장 (블로그용)

#### 2-2. 인덱스 설계
- [ ] 유즈케이스별 쿼리 패턴 분석
  - **Product**: 전체 목록 + 최신순
  - **Product**: 전체 목록 + 좋아요순
  - **Product**: 브랜드 필터 + 최신순
  - **Product**: 브랜드 필터 + 좋아요순
  - **Product**: 브랜드 필터 + 가격순
  - **Like**: 내 좋아요 목록 (member_id)
  - **Like**: 상품별 좋아요 수 (product_id)
- [ ] Product 인덱스 설계
  - `idx_products_brand_likes` → `(brand_id, likes_count DESC)`
  - `idx_products_likes_count` → `(likes_count DESC)`
  - 기타 필요 인덱스
- [ ] Like 인덱스 설계
  - `idx_likes_member_id` → `(member_id)`
  - `idx_likes_product_id` → `(product_id)`

#### 2-3. TO-BE 적용
- [ ] Product 인덱스 추가 (Entity @Index 어노테이션)
- [ ] Like 인덱스 주석 해제 (Entity @Index 어노테이션)
- [ ] 애플리케이션 재시작 (ddl-auto: create)
- [ ] `EXPLAIN` 재분석 (Product + Like)
- [ ] 실행 시간 재측정
- [ ] 전/후 비교 정리 (블로그용)

---

### Task 3: 비정규화 구조 검증 및 문서화

> 이미 구현되어 있으므로 검증 및 문서화 중심

- [ ] 현재 구현 분석
  - `Product.likesCount` 컬럼 구조
  - `LikeService`의 동기화 로직
  - 비관적 락 적용 방식
- [ ] 왜 비정규화를 선택했는지 정리
  - vs COUNT 쿼리
  - vs Materialized View
- [ ] 동시성 테스트 (이미 있다면 확인)
- [ ] 트레이드오프 정리 (블로그용)

---

### Task 4: Redis 캐시 적용

#### 4-1. 캐시 키 설계
- [ ] 상품 상세 캐시 키: `product:{productId}`
- [ ] 상품 목록 캐시 키: `products:brand:{brandId}:sort:{sort}:page:{page}:size:{size}`
- [ ] 캐시 값 직렬화 방식 결정 (JSON)

#### 4-2. 상품 상세 API 캐시 적용
- [ ] `ProductFacade.getProduct()` 또는 별도 캐시 레이어
- [ ] 캐시 히트 시 DB 조회 스킵
- [ ] TTL 설정 (예: 5분)
- [ ] 테스트 작성

#### 4-3. 상품 목록 API 캐시 적용
- [ ] `ProductFacade.getProducts()` 캐시 적용
- [ ] TTL 설정 (예: 1분, 목록은 더 짧게)
- [ ] 테스트 작성

#### 4-4. 캐시 무효화 전략
- [ ] 상품 정보 수정 시 캐시 삭제
- [ ] 좋아요 등록/취소 시 캐시 삭제 (또는 TTL로 자연 만료)
- [ ] 무효화 전략 문서화

#### 4-5. 캐시 미스 처리
- [ ] Redis 연결 실패 시 DB 조회로 폴백
- [ ] 예외 처리 및 로깅

---

### Task 5: 블로그 작성

#### 작성 포인트
- [ ] TL;DR (1줄 요약) 포함
- [ ] AS-IS / TO-BE 비교
- [ ] "왜 그렇게 판단했는가" 중심
- [ ] EXPLAIN 스크린샷 포함
- [ ] 코드 비교 예시 포함

#### 주제 제안
- "좋아요 순으로 정렬하자 서버가 하염없이 느려졌다"
- "우리가 책을 읽을 때, 책갈피가 필요한 이유 (Feat. Index)"
- "상품 목록에 좋아요 수를 포함하려고 했더니!"
- "캐시를 적용했더니 실제 DB로 가던 호출이 줄어들었다"

---

## ✅ 과제 체크리스트 (최종 확인용)

### 🔖 Index
- [ ] 상품 목록 API에서 brandId 기반 검색, 좋아요 순 정렬 등을 처리했다
- [ ] 조회 필터, 정렬 조건별 유즈케이스를 분석하여 인덱스를 적용하고 전/후 성능비교를 진행했다

### ❤️ Structure
- [x] 상품 목록/상세 조회 시 좋아요 수를 조회 및 좋아요 순 정렬이 가능하도록 구조 개선을 진행했다
- [x] 좋아요 적용/해제 진행 시 상품 좋아요 수 또한 정상적으로 동기화되도록 진행하였다

### ⚡ Cache
- [ ] Redis 캐시를 적용하고 TTL 또는 무효화 전략을 적용했다
- [ ] 캐시 미스 상황에서도 서비스가 정상 동작하도록 처리했다

---

## 📅 권장 진행 순서

1. **Task 1: 테스트 데이터 준비** (가장 먼저)
2. **Task 2: 인덱스 최적화** (데이터 있어야 EXPLAIN 의미 있음)
3. **Task 3: 비정규화 검증** (이미 되어있으므로 문서화 중심)
4. **Task 4: Redis 캐시 적용**
5. **Task 5: 블로그 작성** (마지막)

---

## 💡 블로그 작성 시 참고

| 구분 | AS-IS | TO-BE |
|------|-------|-------|
| **인덱스** | EXPLAIN 결과 (Full Scan) | EXPLAIN 결과 (Index Scan) |
| **비정규화** | JOIN으로 COUNT 집계 | `likesCount` 컬럼 직접 조회 |
| **캐시** | 매 요청 DB 조회 | Redis 캐시 + TTL/무효화 |

**글쓰기 팁:**
- "왜 이 인덱스를 선택했는가?"
- "비정규화 vs JOIN vs Materialized View 중 왜 비정규화를 선택했는가?"
- "TTL은 어떤 기준으로 결정했는가?"
- "정합성과 성능 사이의 트레이드오프는?"
