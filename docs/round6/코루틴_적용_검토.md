# ì½”ë£¨í‹´ ì ìš© ê²€í† 

> ğŸ“… ì‘ì„±ì¼: 2025-12-04
>
> ğŸ” í˜„ì¬ í”„ë¡œì íŠ¸ì—ì„œ ì½”ë£¨í‹´ ì ìš©ì´ ìœ ìš©í•œ ë¶€ë¶„ ë¶„ì„

---

## ğŸ¯ ì½”ë£¨í‹´ ì ìš© ê°€ëŠ¥í•œ ì‹œë‚˜ë¦¬ì˜¤

### 1. ìŠ¤ì¼€ì¤„ëŸ¬ - PaymentReconciliationScheduler â­â­â­ (ì¶”ì²œ!)

**í˜„ì¬ êµ¬ì¡° (ì˜ˆìƒ):**
```kotlin
@Component
class PaymentReconciliationScheduler(...) {

    @Scheduled(fixedDelay = 60000)
    fun reconcileStaleOrders() {
        val staleOrders = orderRepository.findByStatusAndCreatedAtBefore(...)

        staleOrders.forEach { order ->
            try {
                reconcileOrder(order)  // ìˆœì°¨ ì²˜ë¦¬ (ëŠë¦¼!)
            } catch (e: Exception) {
                logger.error("Failed to reconcile order: ${order.id}", e)
            }
        }
    }
}
```

**ë¬¸ì œì :**
- 10ë¶„ ì´ìƒ PENDINGì¸ ì£¼ë¬¸ì´ 100ê°œë¼ë©´?
- ê° ì£¼ë¬¸ë§ˆë‹¤ PG API í˜¸ì¶œ (ë„¤íŠ¸ì›Œí¬ I/O)
- ìˆœì°¨ ì²˜ë¦¬ â†’ 100ê°œ * í‰ê·  500ms = 50ì´ˆ ì†Œìš”
- ë‹¤ìŒ ìŠ¤ì¼€ì¤„ ì£¼ê¸°ê¹Œì§€ ë°€ë¦¼

**ì½”ë£¨í‹´ ì ìš©:**
```kotlin
@Component
class PaymentReconciliationScheduler(
    private val orderRepository: OrderRepository,
    private val paymentRepository: PaymentRepository,
    private val productService: ProductService,
    private val pgStrategies: List<PgStrategy>
) {
    private val logger = LoggerFactory.getLogger(javaClass)

    // ì½”ë£¨í‹´ ìŠ¤ì½”í”„ ìƒì„±
    private val coroutineScope = CoroutineScope(
        Dispatchers.IO + SupervisorJob()
    )

    @Scheduled(fixedDelay = 60000)
    fun reconcileStaleOrders() = runBlocking {
        val cutoffTime = LocalDateTime.now().minusMinutes(10)
        val staleOrders = orderRepository.findByStatusAndCreatedAtBefore(
            OrderStatus.PENDING,
            cutoffTime
        )

        if (staleOrders.isEmpty()) return@runBlocking

        logger.info("Found ${staleOrders.size} stale orders to reconcile")

        // ë³‘ë ¬ ì²˜ë¦¬ (ìµœëŒ€ 10ê°œì”©)
        staleOrders.chunked(10).forEach { chunk ->
            chunk.map { order ->
                async(Dispatchers.IO) {
                    try {
                        reconcileOrder(order)
                    } catch (e: Exception) {
                        logger.error("Failed to reconcile order: ${order.id}", e)
                    }
                }
            }.awaitAll()
        }
    }

    @Transactional
    suspend fun reconcileOrder(order: Order) {
        // ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼...
        val payments = paymentRepository.findByOrderId(order.id!!)
        // ...
    }
}
```

**ì¥ì :**
- 100ê°œ ì£¼ë¬¸ì„ 10ê°œì”© ë³‘ë ¬ ì²˜ë¦¬
- ë„¤íŠ¸ì›Œí¬ I/O ëŒ€ê¸° ì‹œê°„ í™œìš©
- ì˜ˆìƒ ì‹œê°„: 100ê°œ * 500ms / 10 = 5ì´ˆ (10ë°° ë¹ ë¦„!)
- `SupervisorJob()`: í•˜ë‚˜ ì‹¤íŒ¨í•´ë„ ë‹¤ë¥¸ ì‘ì—… ê³„ì† ì§„í–‰

---

### 2. PG API í˜¸ì¶œ - Suspend í•¨ìˆ˜ë¡œ ë³€ê²½ â­â­ (ì„ íƒ)

**í˜„ì¬:**
```kotlin
@FeignClient(...)
interface PgSimulatorClient {
    @PostMapping("/api/v1/payments")
    fun requestPayment(...): PgDto.PaymentResponse  // ë¸”ë¡œí‚¹

    @GetMapping("/api/v1/payments/{transactionKey}")
    fun getPaymentStatus(...): PgDto.PaymentStatusResponse  // ë¸”ë¡œí‚¹
}
```

**ë¬¸ì œ:**
- FeignClientëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë™ê¸°/ë¸”ë¡œí‚¹
- PG ì‘ë‹µ ëŒ€ê¸°í•˜ëŠ” ë™ì•ˆ ìŠ¤ë ˆë“œ ì ìœ 

**ì½”ë£¨í‹´ ì ìš© (Retrofit + ì½”ë£¨í‹´):**

í•˜ì§€ë§Œ **í˜„ì‹¤ì  ì–´ë ¤ì›€:**
- Spring Cloud OpenFeignì€ ì½”ë£¨í‹´ ë„¤ì´í‹°ë¸Œ ì§€ì› ì•ˆ í•¨
- Retrofit + ì½”ë£¨í‹´ìœ¼ë¡œ ì „í™˜ í•„ìš”
- ê¸°ì¡´ Resilience4j í†µí•© ì¬ì‘ì—… í•„ìš”

**ê²°ë¡ :**
- **ì ìš© ë¹„ì¶”ì²œ** (íˆ¬ì ëŒ€ë¹„ íš¨ê³¼ ë‚®ìŒ)
- FeignClient + Resilience4jê°€ ì´ë¯¸ ì•ˆì •ì 
- í”„ë¡œë•ì…˜ì—ì„œ ê²€ì¦ëœ ì¡°í•©

---

### 3. ì½œë°± ì²˜ë¦¬ - ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë°œí–‰ â­â­â­ (ì¶”ì²œ!)

**í˜„ì¬:**
```kotlin
@Transactional
fun handlePaymentCallback(callback: PaymentCallbackDto) {
    // 1. Payment ì¡°íšŒ
    val payment = paymentRepository.findByTransactionKey(...)

    // 2. Order ì¡°íšŒ
    val order = orderRepository.findByIdOrThrow(...)

    if (callback.isSuccess()) {
        // 3. ì¬ê³  ì°¨ê° (ì‹œê°„ ì†Œìš”)
        productService.decreaseStockByOrder(order)

        // 4. ìƒíƒœ ì—…ë°ì´íŠ¸
        payment.markAsSuccess()
        order.complete()

        // 5. ì™¸ë¶€ ì•Œë¦¼ (ì´ë©”ì¼, Slack ë“±) - ì—¬ê¸°ì„œ ë¸”ë¡œí‚¹ ë°œìƒ ê°€ëŠ¥!
        // notificationService.sendOrderConfirmation(order)
    }
}
```

**ë¬¸ì œ:**
- PG ì½œë°±ì€ ë¹ ë¥´ê²Œ ì‘ë‹µí•´ì•¼ í•¨ (íƒ€ì„ì•„ì›ƒ ìœ„í—˜)
- ì¬ê³  ì°¨ê°, ì™¸ë¶€ ì•Œë¦¼ì€ ì‹œê°„ì´ ê±¸ë¦¼
- íŠ¸ëœì­ì…˜ì´ ê¸¸ì–´ì§

**ì½”ë£¨í‹´ + ì´ë²¤íŠ¸ ì ìš©:**
```kotlin
@Transactional
fun handlePaymentCallback(callback: PaymentCallbackDto) {
    val payment = paymentRepository.findByTransactionKey(...)
    val order = orderRepository.findByIdOrThrow(...)

    if (callback.isSuccess()) {
        productService.decreaseStockByOrder(order)
        payment.markAsSuccess()
        order.complete()

        // ì´ë²¤íŠ¸ ë°œí–‰ (ë¹„ë™ê¸°)
        eventPublisher.publishEvent(PaymentSuccessEvent(order.id!!))
    }
}

@Component
class PaymentEventListener(
    private val notificationService: NotificationService
) {
    private val coroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    @EventListener
    fun handlePaymentSuccess(event: PaymentSuccessEvent) {
        // ì½”ë£¨í‹´ìœ¼ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬
        coroutineScope.launch {
            try {
                // ì´ë©”ì¼ ë°œì†¡ (ì‹œê°„ ê±¸ë¦¼)
                notificationService.sendOrderConfirmation(event.orderId)

                // Slack ì•Œë¦¼
                notificationService.sendSlackNotification(event.orderId)

                // ì¬ê³  ì•Œë¦¼ (ì¬ê³  ë¶€ì¡± ì‹œ)
                notificationService.checkLowStockAlert(event.orderId)
            } catch (e: Exception) {
                logger.error("Failed to send notifications", e)
            }
        }
    }
}
```

**ì¥ì :**
- PG ì½œë°± ì‘ë‹µ ì†ë„ ê°œì„ 
- íŠ¸ëœì­ì…˜ ë¶„ë¦¬ (ë©”ì¸ íŠ¸ëœì­ì…˜ì€ ë¹ ë¥´ê²Œ ì™„ë£Œ)
- ì•Œë¦¼ ì‹¤íŒ¨í•´ë„ ê²°ì œëŠ” ì„±ê³µ ì²˜ë¦¬

---

### 4. ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬ - Flow ì‚¬ìš© â­â­ (ì„ íƒ)

**ì‹œë‚˜ë¦¬ì˜¤:**
- ë§¤ì¼ 00:00ì— ëª¨ë“  ì£¼ë¬¸ í†µê³„ ìƒì„±
- 10ë§Œ ê°œ ì£¼ë¬¸ ì¡°íšŒ â†’ ë©”ëª¨ë¦¬ ë¶€ë‹´

**í˜„ì¬:**
```kotlin
fun generateDailyReport(): Report {
    val allOrders = orderRepository.findAll()  // ë©”ëª¨ë¦¬ì— 10ë§Œ ê°œ ë¡œë“œ!
    // í†µê³„ ê³„ì‚°...
}
```

**ì½”ë£¨í‹´ Flow ì ìš©:**
```kotlin
fun generateDailyReport() = runBlocking {
    orderRepository.findAllAsFlow()  // Flowë¡œ ìŠ¤íŠ¸ë¦¬ë°
        .filter { it.status == OrderStatus.COMPLETED }
        .map { order ->
            OrderStat(
                orderId = order.id!!,
                amount = order.finalAmount.amount,
                date = order.createdAt.toLocalDate()
            )
        }
        .toList()  // í•„ìš”í•œ ë°ì´í„°ë§Œ ìˆ˜ì§‘
}
```

**í•˜ì§€ë§Œ:**
- í˜„ì¬ í”„ë¡œì íŠ¸ ê·œëª¨ì—ì„œëŠ” ê³¼ë„í•¨
- ìˆ˜ë°±ë§Œ ê±´ ì´ìƒì¼ ë•Œ ìœ ìš©
- **ì ìš© ë¹„ì¶”ì²œ** (í˜„ì¬ëŠ” ë¶ˆí•„ìš”)

---

## ğŸ“Š ì ìš© ìš°ì„ ìˆœìœ„

### 1ìˆœìœ„: ìŠ¤ì¼€ì¤„ëŸ¬ ë³‘ë ¬ ì²˜ë¦¬ â­â­â­â­â­
**ì´ìœ :**
- ëª…í™•í•œ ì„±ëŠ¥ ê°œì„  (10ë°° ë¹ ë¦„)
- êµ¬í˜„ ê°„ë‹¨
- ë¶€ì‘ìš© ì—†ìŒ
- ì‹¤ë¬´ì—ì„œ ìì£¼ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´

**ì˜ˆìƒ êµ¬í˜„ ì‹œê°„:** 30ë¶„

---

### 2ìˆœìœ„: ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬ â­â­â­â­
**ì´ìœ :**
- PG ì½œë°± ì‘ë‹µ ì†ë„ ê°œì„ 
- í™•ì¥ì„± ì¢‹ìŒ (ì•Œë¦¼ ì¶”ê°€ ì‰¬ì›€)
- Spring Event + ì½”ë£¨í‹´ ì¡°í•©

**ì˜ˆìƒ êµ¬í˜„ ì‹œê°„:** 1ì‹œê°„

---

### ë¹„ì¶”ì²œ: PG Client ì½”ë£¨í‹´ ì „í™˜ âŒ
**ì´ìœ :**
- FeignClient â†’ Retrofit ì „í™˜ ë¹„ìš© í¼
- Resilience4j ì¬ì‘ì—… í•„ìš”
- í˜„ì¬ êµ¬ì¡°ë¡œ ì¶©ë¶„

---

### ë¹„ì¶”ì²œ: Flow ê¸°ë°˜ ëŒ€ëŸ‰ ì²˜ë¦¬ âŒ
**ì´ìœ :**
- í˜„ì¬ ë°ì´í„° ê·œëª¨ì—ì„œ ë¶ˆí•„ìš”
- ë³µì¡ë„ë§Œ ì¦ê°€
- ìˆ˜ë°±ë§Œ ê±´ ì´ìƒì¼ ë•Œ ê³ ë ¤

---

## ğŸ›  êµ¬í˜„ ê°€ì´ë“œ

### 1. ì˜ì¡´ì„± ì¶”ê°€

**build.gradle.kts:**
```kotlin
dependencies {
    // ì½”ë£¨í‹´
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.7.3")
}
```

---

### 2. ìŠ¤ì¼€ì¤„ëŸ¬ ë³‘ë ¬ ì²˜ë¦¬ êµ¬í˜„

**PaymentReconciliationScheduler.kt:**
```kotlin
package com.loopers.domain.payment

import kotlinx.coroutines.*
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDateTime

@Component
class PaymentReconciliationScheduler(
    private val orderRepository: OrderRepository,
    private val paymentRepository: PaymentRepository,
    private val productService: ProductService,
    private val pgStrategies: List<PgStrategy>
) {
    private val logger = LoggerFactory.getLogger(javaClass)

    // ì½”ë£¨í‹´ ìŠ¤ì½”í”„ (ì• í”Œë¦¬ì¼€ì´ì…˜ ìƒëª…ì£¼ê¸°ì™€ í•¨ê»˜)
    private val coroutineScope = CoroutineScope(
        Dispatchers.IO + SupervisorJob()
    )

    @Scheduled(fixedDelay = 60000) // 1ë¶„ë§ˆë‹¤
    fun reconcileStaleOrders() = runBlocking {
        val cutoffTime = LocalDateTime.now().minusMinutes(10)

        val staleOrders = orderRepository.findByStatusAndCreatedAtBefore(
            OrderStatus.PENDING,
            cutoffTime
        )

        if (staleOrders.isEmpty()) {
            return@runBlocking
        }

        logger.info("Found ${staleOrders.size} stale orders to reconcile")

        // 10ê°œì”© ë¬¶ì–´ì„œ ë³‘ë ¬ ì²˜ë¦¬
        staleOrders.chunked(10).forEach { chunk ->
            chunk.map { order ->
                async(Dispatchers.IO) {
                    try {
                        reconcileOrder(order)
                    } catch (e: Exception) {
                        logger.error("Failed to reconcile order: ${order.id}", e)
                    }
                }
            }.awaitAll()  // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        }

        logger.info("Reconciliation completed for ${staleOrders.size} orders")
    }

    @Transactional
    fun reconcileOrder(order: Order) {
        // ê¸°ì¡´ ë¡œì§ê³¼ ë™ì¼
        val payments = paymentRepository.findByOrderId(order.id!!)
        val pendingPayment = payments.firstOrNull { it.status == PaymentStatus.PENDING }

        if (pendingPayment == null) {
            order.fail()
            logger.info("No pending payment found. Order marked as FAILED: ${order.id}")
            return
        }

        if (pendingPayment.transactionKey == null) {
            pendingPayment.markAsFailed("PG ìš”ì²­ ì‹¤íŒ¨")
            order.fail()
            logger.info("Payment request failed. Order marked as FAILED: ${order.id}")
            return
        }

        try {
            val pgStrategy = pgStrategies.firstOrNull {
                it.supports(pendingPayment.paymentMethod)
            } ?: throw IllegalStateException("No PG strategy found")

            val userId = order.memberId
            val pgStatus = pgStrategy.getPaymentStatus(userId, pendingPayment.transactionKey!!)

            when (pgStatus.status) {
                "SUCCESS" -> {
                    try {
                        productService.decreaseStockByOrder(order)
                        pendingPayment.markAsSuccess()
                        order.complete()
                        logger.info("Recovered payment: orderId=${order.id}, transactionKey=${pendingPayment.transactionKey}")
                    } catch (e: Exception) {
                        pendingPayment.markAsFailed("ì¬ê³  ë¶€ì¡±: ${e.message}")
                        order.fail()
                        logger.error("Out of stock during reconciliation: orderId=${order.id}")
                    }
                }
                "FAILED" -> {
                    pendingPayment.markAsFailed(pgStatus.failureReason ?: "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
                    order.fail()
                    logger.info("Payment failed during reconciliation: orderId=${order.id}")
                }
                else -> {
                    logger.debug("Payment still pending: orderId=${order.id}")
                }
            }
        } catch (e: Exception) {
            logger.warn("Failed to query PG status: orderId=${order.id}", e)
        }
    }

    // ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ ì‹œ ì½”ë£¨í‹´ ì •ë¦¬
    @PreDestroy
    fun cleanup() {
        coroutineScope.cancel()
    }
}
```

---

### 3. í…ŒìŠ¤íŠ¸

**ì„±ëŠ¥ ë¹„êµ í…ŒìŠ¤íŠ¸:**
```kotlin
@Test
fun `ìŠ¤ì¼€ì¤„ëŸ¬ ì„±ëŠ¥ ë¹„êµ`() = runBlocking {
    val orders = (1..100).map { createTestOrder() }

    // ìˆœì°¨ ì²˜ë¦¬
    val sequentialTime = measureTimeMillis {
        orders.forEach { order ->
            reconcileOrder(order)
        }
    }

    // ë³‘ë ¬ ì²˜ë¦¬ (10ê°œì”©)
    val parallelTime = measureTimeMillis {
        orders.chunked(10).forEach { chunk ->
            chunk.map { order ->
                async(Dispatchers.IO) {
                    reconcileOrder(order)
                }
            }.awaitAll()
        }
    }

    logger.info("ìˆœì°¨: ${sequentialTime}ms, ë³‘ë ¬: ${parallelTime}ms")
    assertThat(parallelTime).isLessThan(sequentialTime / 5)
}
```

---

## âš ï¸ ì£¼ì˜ì‚¬í•­

### 1. íŠ¸ëœì­ì…˜ ê²½ê³„
```kotlin
// âŒ ì˜ëª»ëœ ì˜ˆ
@Transactional
fun reconcileStaleOrders() = runBlocking {
    staleOrders.map { order ->
        async { reconcileOrder(order) }  // íŠ¸ëœì­ì…˜ì´ ì½”ë£¨í‹´ ê²½ê³„ë¥¼ ë„˜ì–´ê°!
    }.awaitAll()
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ
fun reconcileStaleOrders() = runBlocking {
    staleOrders.map { order ->
        async { reconcileOrder(order) }  // reconcileOrderê°€ @Transactional
    }.awaitAll()
}
```

### 2. ì˜ˆì™¸ ì²˜ë¦¬
```kotlin
// SupervisorJob ì‚¬ìš©: í•˜ë‚˜ ì‹¤íŒ¨í•´ë„ ë‹¤ë¥¸ ì‘ì—… ê³„ì†
private val coroutineScope = CoroutineScope(
    Dispatchers.IO + SupervisorJob()  // ì¤‘ìš”!
)
```

### 3. ì½”ë£¨í‹´ ìŠ¤ì½”í”„ ìƒëª…ì£¼ê¸°
```kotlin
@PreDestroy
fun cleanup() {
    coroutineScope.cancel()  // ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ ì‹œ ì •ë¦¬ í•„ìˆ˜!
}
```

---

## ğŸ’¬ ë…¼ì˜ í•„ìš”

### ì§ˆë¬¸ 1: ìŠ¤ì¼€ì¤„ëŸ¬ ë³‘ë ¬ ì²˜ë¦¬ ì ìš©í• ê¹Œìš”?
- **ì¥ì :** ëª…í™•í•œ ì„±ëŠ¥ ê°œì„  (10ë°°)
- **ë‹¨ì :** ì½”ë£¨í‹´ ì˜ì¡´ì„± ì¶”ê°€
- **ì¶”ì²œ:** âœ… ì ìš© ê¶Œì¥

### ì§ˆë¬¸ 2: ë™ì‹œ ì²˜ë¦¬ ê°œìˆ˜ëŠ” ëª‡ ê°œë¡œ?
- í˜„ì¬ ì œì•ˆ: 10ê°œ
- CPU ì½”ì–´ ìˆ˜ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥
- **ì¶”ì²œ:** 10~20ê°œ (ë„ˆë¬´ ë§ìœ¼ë©´ PG API ë¶€í•˜)

### ì§ˆë¬¸ 3: ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸°ë„ ì ìš©í• ê¹Œìš”?
- ì•Œë¦¼ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ìœ ìš©
- í˜„ì¬ëŠ” ì•Œë¦¼ ì—†ìœ¼ë¯€ë¡œ ë³´ë¥˜ ê°€ëŠ¥
- **ì¶”ì²œ:** â¸ï¸ ì•Œë¦¼ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê³ ë ¤

---

## ğŸ¯ ìµœì¢… ì¶”ì²œ

### ì¦‰ì‹œ ì ìš© ì¶”ì²œ âœ…
1. **ìŠ¤ì¼€ì¤„ëŸ¬ ë³‘ë ¬ ì²˜ë¦¬** (30ë¶„ íˆ¬ì, 10ë°° ì„±ëŠ¥ í–¥ìƒ)

### ë³´ë¥˜ ê¶Œì¥ â¸ï¸
2. PG Client ì½”ë£¨í‹´ ì „í™˜ (ë¹„ìš© > íš¨ê³¼)
3. Flow ê¸°ë°˜ ì²˜ë¦¬ (í˜„ì¬ ê·œëª¨ì—ì„œ ë¶ˆí•„ìš”)
4. ì´ë²¤íŠ¸ ë¹„ë™ê¸° ì²˜ë¦¬ (ì•Œë¦¼ ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê³ ë ¤)

---

**ì‘ì„±ì¼:** 2025-12-04
**ê²€í† ì:** ì‚¬ìš©ì í™•ì¸ í•„ìš”
