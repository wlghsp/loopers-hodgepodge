# Round 6 ê³¼ì œ ì²´í¬ë¦¬ìŠ¤íŠ¸ ë° êµ¬í˜„ ê°€ì´ë“œ

> ğŸ“… ì‘ì„±ì¼: 2025-12-04
>
> ğŸ“‹ ì´ ë¬¸ì„œëŠ” ê³¼ì œ ìš”êµ¬ì‚¬í•­ê³¼ í˜„ì¬ ì‘ì—… ìƒíƒœë¥¼ ë¹„êµí•˜ì—¬ ë‚¨ì€ ì‘ì—…ì„ ëª…í™•íˆ ì •ë¦¬í•©ë‹ˆë‹¤.

---

## âœ… ê³¼ì œ ìš”êµ¬ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ğŸ“¦ ì¶”ê°€ ìš”êµ¬ì‚¬í•­

#### 1. PG ì—°ë™ API êµ¬í˜„
- [x] **ê²°ì œ ìš”ì²­ API ì—°ë™**
  - âœ… `POST /api/v1/payments` êµ¬í˜„ ì™„ë£Œ
  - âœ… FeignClient ì‚¬ìš© (`PgSimulatorClient.kt`)
  - âœ… X-USER-ID í—¤ë” ì „ì†¡
  - âœ… DTO ì •ì˜: `PgPaymentRequest`, `PgPaymentResponse`

- [x] **ê²°ì œ ì •ë³´ í™•ì¸ API ì—°ë™**
  - âœ… `GET /api/v1/payments/{transactionKey}` êµ¬í˜„ ì™„ë£Œ
  - âœ… `PgSimulatorClient.getPaymentStatus()` ë©”ì„œë“œ

- [x] **ì£¼ë¬¸ë³„ ê²°ì œ ì •ë³´ ì¡°íšŒ API ì—°ë™**
  - âœ… `GET /api/v1/payments?orderId={orderId}` êµ¬í˜„ ì™„ë£Œ
  - âœ… `PgSimulatorClient.getPaymentsByOrderId()` ë©”ì„œë“œ

#### 2. ë¹„ë™ê¸° ê²°ì œ íŠ¹ì„± ì´í•´ ë° êµ¬í˜„
- [x] **ë¹„ë™ê¸° ê²°ì œ ì´í•´**
  - âœ… ìš”ì²­ê³¼ ì²˜ë¦¬ ë¶„ë¦¬ ê°œë… íŒŒì•…
  - âœ… ìš”ì²­ ì„±ê³µ í™•ë¥ : 60%
  - âœ… ìš”ì²­ ì§€ì—°: 100ms ~ 500ms
  - âœ… ì²˜ë¦¬ ì§€ì—°: 1s ~ 5s
  - âœ… ì²˜ë¦¬ ê²°ê³¼: ì„±ê³µ 70%, í•œë„ ì´ˆê³¼ 20%, ì˜ëª»ëœ ì¹´ë“œ 10%

- [x] **ì½œë°± ë°©ì‹ êµ¬í˜„**
  - âœ… `PaymentCallbackController.kt` ìƒì„±
  - âœ… `PaymentCallbackService.kt` êµ¬í˜„
  - âœ… ë©±ë“±ì„± ë³´ì¥ (ì¤‘ë³µ ì½œë°± ë¬´ì‹œ)

---

### âš¡ PG ì—°ë™ ëŒ€ì‘ (Must-Have)

- [x] **PG ì—°ë™ APIëŠ” RestTemplate í˜¹ì€ FeignClientë¡œ ì™¸ë¶€ ì‹œìŠ¤í…œì„ í˜¸ì¶œí•œë‹¤.**
  - âœ… FeignClient ì‚¬ìš© (`@FeignClient` ì–´ë…¸í…Œì´ì…˜)
  - âœ… `PgSimulatorClient` ì¸í„°í˜ì´ìŠ¤ ì •ì˜
  - âœ… `PgClientConfig`ì—ì„œ Timeout ì„¤ì •

- [x] **ì‘ë‹µ ì§€ì—°ì— ëŒ€í•´ íƒ€ì„ì•„ì›ƒì„ ì„¤ì •í•˜ê³ , ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ì„ êµ¬í˜„í•œë‹¤.**
  - âœ… connectTimeout: 1ì´ˆ
  - âœ… readTimeout: 3ì´ˆ
  - âœ… Fallback ë©”ì„œë“œ êµ¬í˜„ (`paymentFallback`)
  - âœ… ì˜ˆì™¸ ì²˜ë¦¬: `CoreException` ë°œìƒ

- [x] **ê²°ì œ ìš”ì²­ì— ëŒ€í•œ ì‹¤íŒ¨ ì‘ë‹µì— ëŒ€í•´ ì ì ˆí•œ ì‹œìŠ¤í…œ ì—°ë™ì„ ì§„í–‰í•œë‹¤.**
  - âœ… ê²°ì œ ì‹¤íŒ¨ ì‹œ Order ì‹¤íŒ¨ ì²˜ë¦¬ (`order.fail()`)
  - âœ… Payment ì‹¤íŒ¨ ê¸°ë¡ ìƒì„±
  - âœ… ì¬ê³  ì°¨ê°í•˜ì§€ ì•ŠìŒ (GMV ë³´í˜¸)

- [x] **ì½œë°± ë°©ì‹ + ê²°ì œ ìƒíƒœ í™•ì¸ APIë¥¼ í™œìš©í•´ ì ì ˆí•˜ê²Œ ì‹œìŠ¤í…œê³¼ ê²°ì œì •ë³´ë¥¼ ì—°ë™í•œë‹¤.**
  - âœ… ì½œë°± ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ (`/api/v1/payments/callback`)
  - âœ… ê²°ì œ ìƒíƒœ ì¡°íšŒ API ì¤€ë¹„ (`getPaymentStatus`)
  - âš ï¸ **ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ë³µêµ¬ ë¡œì§ ë¯¸êµ¬í˜„** (ì•„ë˜ ì°¸ì¡°)

---

### ğŸ›¡ Resilience ì„¤ê³„ (Must-Have)

- [x] **ì„œí‚· ë¸Œë ˆì´ì»¤ í˜¹ì€ ì¬ì‹œë„ ì •ì±…ì„ ì ìš©í•˜ì—¬ ì¥ì•  í™•ì‚°ì„ ë°©ì§€í•œë‹¤.**
  - âœ… CircuitBreaker ì ìš© (`@CircuitBreaker` ì–´ë…¸í…Œì´ì…˜)
  - âœ… `application.yml`ì— Resilience4j ì„¤ì •
  - âœ… failure-rate-threshold: 60%
  - âœ… slow-call-duration-threshold: 2s
  - âœ… wait-duration-in-open-state: 10s
  - âŒ **Retry ì •ì±… ë¯¸ì ìš©** (Nice-to-Have, ì„ íƒì‚¬í•­)

- [x] **ì™¸ë¶€ ì‹œìŠ¤í…œ ì¥ì•  ì‹œì—ë„ ë‚´ë¶€ ì‹œìŠ¤í…œì€ ì •ìƒì ìœ¼ë¡œ ì‘ë‹µí•˜ë„ë¡ ë³´í˜¸í•œë‹¤.**
  - âœ… Fallback ë©”ì„œë“œë¡œ ì¦‰ì‹œ ì‘ë‹µ
  - âœ… ì¬ê³  ë¬¶ì´ì§€ ì•ŠìŒ (ì°¨ê°í•˜ì§€ ì•ŠìŒ)
  - âœ… ì‚¬ìš©ìì—ê²Œ ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€ ë°˜í™˜

- [ ] **ì½œë°±ì´ ì˜¤ì§€ ì•Šë”ë¼ë„, ì¼ì • ì£¼ê¸° í˜¹ì€ ìˆ˜ë™ API í˜¸ì¶œë¡œ ìƒíƒœë¥¼ ë³µêµ¬í•  ìˆ˜ ìˆë‹¤.**
  - âŒ **ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ë³µêµ¬ ë¡œì§ ë¯¸êµ¬í˜„** (í•µì‹¬!)
  - âŒ `PaymentReconciliationScheduler` ë¯¸ì‘ì„±
  - âŒ `@EnableScheduling` ë¯¸ì„¤ì •
  - âŒ `OrderRepository.findByStatusAndCreatedAtBefore()` ë¯¸êµ¬í˜„

- [ ] **PGì— ëŒ€í•œ ìš”ì²­ì´ íƒ€ì„ì•„ì›ƒì— ì˜í•´ ì‹¤íŒ¨ë˜ë”ë¼ë„ í•´ë‹¹ ê²°ì œê±´ì— ëŒ€í•œ ì •ë³´ë¥¼ í™•ì¸í•˜ì—¬ ì •ìƒì ìœ¼ë¡œ ì‹œìŠ¤í…œì— ë°˜ì˜í•œë‹¤.**
  - âš ï¸ **ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ë³µêµ¬í•˜ëŠ” ë¡œì§ì´ í•„ìš”** (ìœ„ì™€ ì—°ê²°)
  - âœ… PG ìƒíƒœ ì¡°íšŒ APIëŠ” ì¤€ë¹„ë¨ (`getPaymentStatus`)

---

## ğŸš¨ ë‚¨ì€ í•„ìˆ˜ ì‘ì—… (Must-Have)

### 1. ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ì£¼ë¬¸ ëŒ€ì‚¬ (ë³µêµ¬ ë¡œì§) - ìµœìš°ì„ !

**ì¤‘ìš”ë„:** â­â­â­â­â­ (í•„ìˆ˜!)

**ë°°ê²½:**
- ê³¼ì œ ìš”êµ¬ì‚¬í•­: "ì½œë°±ì´ ì˜¤ì§€ ì•Šë”ë¼ë„, ì¼ì • ì£¼ê¸° í˜¹ì€ ìˆ˜ë™ API í˜¸ì¶œë¡œ ìƒíƒœë¥¼ ë³µêµ¬í•  ìˆ˜ ìˆë‹¤."
- í˜„ì¬ ìƒíƒœ: ì½œë°±ë§Œ ì˜ì¡´, ì½œë°± ëˆ„ë½ ì‹œ ë³µêµ¬ ë¶ˆê°€

**êµ¬í˜„ ê°€ì´ë“œ:**

#### 1-1. `@EnableScheduling` í™œì„±í™”

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/CommerceApiApplication.kt`

```kotlin
package com.loopers

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication
@EnableScheduling  // ì¶”ê°€!
class CommerceApiApplication

fun main(args: Array<String>) {
    runApplication<CommerceApiApplication>(*args)
}
```

---

#### 1-2. `OrderRepository`ì— ë©”ì„œë“œ ì¶”ê°€

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/order/OrderRepository.kt`

```kotlin
interface OrderRepository : JpaRepository<Order, Long> {
    // ê¸°ì¡´ ë©”ì„œë“œë“¤...

    // ì¶”ê°€: íŠ¹ì • ìƒíƒœì´ë©´ì„œ ìƒì„± ì‹œê°„ì´ íŠ¹ì • ì‹œì  ì´ì „ì¸ ì£¼ë¬¸ ì¡°íšŒ
    fun findByStatusAndCreatedAtBefore(
        status: OrderStatus,
        time: LocalDateTime
    ): List<Order>
}
```

---

#### 1-3. `PaymentReconciliationScheduler` ìƒì„±

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/PaymentReconciliationScheduler.kt`

```kotlin
package com.loopers.domain.payment

import com.loopers.domain.order.OrderRepository
import com.loopers.domain.order.OrderStatus
import com.loopers.domain.payment.strategy.PgStrategy
import com.loopers.domain.product.ProductService
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDateTime

@Component
class PaymentReconciliationScheduler(
    private val orderRepository: OrderRepository,
    private val paymentRepository: PaymentRepository,
    private val productService: ProductService,
    private val pgStrategies: List<PgStrategy>
) {
    private val logger = LoggerFactory.getLogger(javaClass)

    /**
     * 1ë¶„ë§ˆë‹¤ ì‹¤í–‰
     * 10ë¶„ ì´ìƒ PENDING ìƒíƒœì¸ ì£¼ë¬¸ì„ ì°¾ì•„ì„œ PG ìƒíƒœë¥¼ ì¡°íšŒí•˜ê³  ë³µêµ¬
     */
    @Scheduled(fixedDelay = 60000) // 1ë¶„ = 60,000ms
    fun reconcileStaleOrders() {
        val cutoffTime = LocalDateTime.now().minusMinutes(10)

        // PENDING ìƒíƒœê°€ 10ë¶„ ì´ìƒì¸ ì£¼ë¬¸ë“¤ ì¡°íšŒ
        val staleOrders = orderRepository.findByStatusAndCreatedAtBefore(
            OrderStatus.PENDING,
            cutoffTime
        )

        if (staleOrders.isEmpty()) {
            return
        }

        logger.info("Found ${staleOrders.size} stale orders to reconcile")

        staleOrders.forEach { order ->
            try {
                reconcileOrder(order)
            } catch (e: Exception) {
                logger.error("Failed to reconcile order: ${order.id}", e)
            }
        }
    }

    @Transactional
    fun reconcileOrder(order: Order) {
        // 1. í•´ë‹¹ ì£¼ë¬¸ì˜ Payment ì¡°íšŒ
        val payments = paymentRepository.findByOrderId(order.id!!)
        val pendingPayment = payments.firstOrNull { it.status == PaymentStatus.PENDING }

        if (pendingPayment == null) {
            // Paymentê°€ ì—†ê±°ë‚˜ ëª¨ë‘ ì‹¤íŒ¨ â†’ Orderë„ ì‹¤íŒ¨ ì²˜ë¦¬
            order.fail()
            logger.info("No pending payment found. Order marked as FAILED: ${order.id}")
            return
        }

        if (pendingPayment.transactionKey == null) {
            // PG ìš”ì²­ ìì²´ê°€ ì‹¤íŒ¨í•œ ì¼€ì´ìŠ¤
            pendingPayment.markAsFailed("PG ìš”ì²­ ì‹¤íŒ¨")
            order.fail()
            logger.info("Payment request failed. Order marked as FAILED: ${order.id}")
            return
        }

        // 2. PGì— ì‹¤ì œ ìƒíƒœ í™•ì¸
        try {
            val pgStrategy = pgStrategies.firstOrNull {
                it.supports(pendingPayment.paymentMethod)
            } ?: throw IllegalStateException("No PG strategy found")

            // TODO: userIdë¥¼ Orderì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
            val userId = order.memberId
            val pgStatus = pgStrategy.getPaymentStatus(userId, pendingPayment.transactionKey!!)

            when (pgStatus.status) {
                "SUCCESS" -> {
                    // ì½œë°± ëˆ„ë½ ì¼€ì´ìŠ¤ â†’ ìˆ˜ë™ ë³µêµ¬
                    try {
                        productService.decreaseStockByOrder(order)
                        pendingPayment.markAsSuccess()
                        order.complete()
                        logger.info("Recovered payment: orderId=${order.id}, transactionKey=${pendingPayment.transactionKey}")
                    } catch (e: Exception) {
                        // ì¬ê³  ë¶€ì¡± ì‹œ PG ì·¨ì†Œ í•„ìš” (TODO)
                        pendingPayment.markAsFailed("ì¬ê³  ë¶€ì¡±: ${e.message}")
                        order.fail()
                        logger.error("Out of stock during reconciliation: orderId=${order.id}")
                    }
                }
                "FAILED" -> {
                    pendingPayment.markAsFailed(pgStatus.failureReason ?: "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
                    order.fail()
                    logger.info("Payment failed during reconciliation: orderId=${order.id}")
                }
                else -> {
                    // ì•„ì§ PENDING â†’ ê³„ì† ëŒ€ê¸°
                    logger.debug("Payment still pending: orderId=${order.id}")
                }
            }
        } catch (e: Exception) {
            // PG ì¡°íšŒë„ ì‹¤íŒ¨ â†’ ë‹¤ìŒ ì£¼ê¸°ì— ì¬ì‹œë„
            logger.warn("Failed to query PG status: orderId=${order.id}", e)
        }
    }
}
```

**ì£¼ì˜ì‚¬í•­:**
- `order.memberId`ê°€ Stringì¸ì§€ í™•ì¸ í•„ìš”
- `ProductService.decreaseStockByOrder(order)` ë©”ì„œë“œ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ í•„ìš”
- `PgDto.PaymentStatusResponse`ì— `status`, `failureReason` í•„ë“œ ìˆëŠ”ì§€ í™•ì¸

---

#### 1-4. `ProductService`ì— ë©”ì„œë“œ ì¶”ê°€ (í•„ìš”ì‹œ)

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/product/ProductService.kt`

```kotlin
@Transactional
fun decreaseStockByOrder(order: Order) {
    order.items.forEach { item ->
        val product = productRepository.findByIdWithLock(item.productId)
            ?: throw CoreException(ErrorType.PRODUCT_NOT_FOUND)
        product.decreaseStock(item.quantity)
    }
}
```

---

### 2. ì¬ê³  ë¶€ì¡± ì‹œ PG ì·¨ì†Œ ìš”ì²­ êµ¬í˜„ - ì¤‘ìš”!

**ì¤‘ìš”ë„:** â­â­â­â­ (ì¤‘ìš”!)

**ë°°ê²½:**
- ì½œë°± ì„±ê³µ ì‹œì ì— ì¬ê³  ë¶€ì¡± ë°œìƒ ê°€ëŠ¥
- ì´ë¯¸ PGì—ì„œ ê²°ì œ ìŠ¹ì¸ë˜ì—ˆìœ¼ë¯€ë¡œ ì·¨ì†Œ ìš”ì²­ í•„ìš”

**êµ¬í˜„ ê°€ì´ë“œ:**

#### 2-1. `PgSimulatorClient`ì— ì·¨ì†Œ API ì¶”ê°€

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/pg/PgSimulatorClient.kt`

```kotlin
@FeignClient(
    name = "pg-simulator",
    url = "\${pg.base-url}",
    configuration = [PgClientConfig::class]
)
interface PgSimulatorClient {
    // ê¸°ì¡´ ë©”ì„œë“œë“¤...

    // ì¶”ê°€: ê²°ì œ ì·¨ì†Œ
    @PostMapping("/api/v1/payments/{transactionKey}/cancel")
    fun cancelPayment(
        @RequestHeader("X-USER-ID") userId: String,
        @PathVariable transactionKey: String
    ): PgDto.CancelResponse
}
```

#### 2-2. `PgDto`ì— ì·¨ì†Œ ì‘ë‹µ DTO ì¶”ê°€

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/pg/PgDto.kt`

```kotlin
object PgDto {
    // ê¸°ì¡´ DTOë“¤...

    data class CancelResponse(
        val transactionKey: String,
        val status: String,
        val message: String
    )
}
```

#### 2-3. `PgStrategy` ì¸í„°í˜ì´ìŠ¤ì— ì·¨ì†Œ ë©”ì„œë“œ ì¶”ê°€

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/strategy/PgStrategy.kt`

```kotlin
interface PgStrategy {
    fun supports(paymentMethod: PaymentMethod): Boolean
    fun requestPayment(userId: String, request: PgDto.PaymentRequest): PgDto.PaymentResponse
    fun getPaymentStatus(userId: String, transactionKey: String): PgDto.PaymentStatusResponse

    // ì¶”ê°€: ê²°ì œ ì·¨ì†Œ
    fun cancelPayment(userId: String, transactionKey: String): PgDto.CancelResponse
}
```

#### 2-4. `SimulatorPgStrategy`ì— ì·¨ì†Œ ë©”ì„œë“œ êµ¬í˜„

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/strategy/SimulatorPgStrategy.kt`

```kotlin
@Component
class SimulatorPgStrategy(
    private val pgSimulatorClient: PgSimulatorClient
) : PgStrategy {
    // ê¸°ì¡´ ë©”ì„œë“œë“¤...

    override fun cancelPayment(userId: String, transactionKey: String): PgDto.CancelResponse {
        return pgSimulatorClient.cancelPayment(userId, transactionKey)
    }
}
```

#### 2-5. `PaymentCallbackService`ì—ì„œ ì·¨ì†Œ í˜¸ì¶œ

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/PaymentCallbackService.kt`

```kotlin
@Component
class PaymentCallbackService(
    private val paymentRepository: PaymentRepository,
    private val orderRepository: OrderRepository,
    private val productService: ProductService,
    private val pgStrategies: List<PgStrategy>  // ì¶”ê°€!
) {
    private val logger = LoggerFactory.getLogger(javaClass)

    @Transactional
    fun handlePaymentCallback(callback: PaymentCallbackDto) {
        logger.info("Payment callback received: transactionKey=${callback.transactionKey}, status=${callback.status}")

        val payment = paymentRepository.findByTransactionKey(callback.transactionKey)
            ?: throw CoreException(ErrorType.PAYMENT_NOT_FOUND)

        if (payment.status != PaymentStatus.PENDING) {
            logger.warn("Already processed payment: paymentId=${payment.id}, status=${payment.status}")
            return
        }

        val order = orderRepository.findByIdOrThrow(payment.orderId)

        if (callback.isSuccess()) {
            try {
                productService.decreaseStockByOrder(order)
                payment.markAsSuccess()
                order.complete()
                logger.info("Payment success: orderId=${order.id}, transactionKey=${callback.transactionKey}")
            } catch (e: Exception) {
                // ì¬ê³  ë¶€ì¡± ë“± ì‹¤íŒ¨ ì‹œ - PG ì·¨ì†Œ ìš”ì²­
                try {
                    val pgStrategy = pgStrategies.firstOrNull {
                        it.supports(payment.paymentMethod)
                    }

                    if (pgStrategy != null && payment.transactionKey != null) {
                        // TODO: userIdë¥¼ Orderì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
                        val userId = order.memberId
                        pgStrategy.cancelPayment(userId, payment.transactionKey!!)
                        logger.info("PG payment cancelled: transactionKey=${payment.transactionKey}")
                    }
                } catch (cancelEx: Exception) {
                    logger.error("Failed to cancel PG payment: ${payment.transactionKey}", cancelEx)
                }

                payment.markAsFailed("ì¬ê³  ì°¨ê° ì‹¤íŒ¨: ${e.message}")
                order.fail()
                logger.error("Payment processing failed: orderId=${order.id}", e)

                // TODO: CS íŒ€ ì•Œë¦¼
            }
        } else {
            payment.markAsFailed(callback.reason ?: "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
            order.fail()
            logger.warn("Payment failed: orderId=${order.id}, reason=${callback.reason}")
        }
    }
}
```

---

### 3. Orderì— memberId í•„ë“œ í™•ì¸ ë° í™œìš©

**ë°°ê²½:**
- PG API í˜¸ì¶œ ì‹œ X-USER-ID í—¤ë” í•„ìš”
- ìŠ¤ì¼€ì¤„ëŸ¬/ì½œë°±ì—ì„œ Orderë§Œ ìˆì„ ë•Œ userIdë¥¼ ê°€ì ¸ì™€ì•¼ í•¨

**í™•ì¸ ì‚¬í•­:**
```kotlin
// Order í´ë˜ìŠ¤ì— memberId í•„ë“œê°€ ìˆëŠ”ì§€ í™•ì¸
class Order {
    val memberId: String  // ì´ í•„ë“œê°€ ìˆì–´ì•¼ í•¨
    // ...
}
```

**ë§Œì•½ ì—†ë‹¤ë©´:**
- Order ìƒì„± ì‹œ memberIdë¥¼ ì €ì¥í•˜ë„ë¡ ìˆ˜ì • í•„ìš”

---

## ğŸ¯ Nice-to-Have ì‘ì—… (ì„ íƒì‚¬í•­)

### 1. Retry ì •ì±… ì ìš© (ì„ íƒ)

**ì¤‘ìš”ë„:** â­â­ (ì„ íƒì‚¬í•­)

**ë°°ê²½:**
- ê³¼ì œì—ì„œ Nice-to-Haveë¡œ ëª…ì‹œ
- ì¼ì‹œì  ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ëŒ€ì‘

**êµ¬í˜„ ê°€ì´ë“œ:**

```yaml
# application.yml
resilience4j:
  retry:
    instances:
      pgRetry:
        max-attempts: 2
        wait-duration: 500ms
        retry-exceptions:
          - java.net.ConnectException
          - feign.RetryableException
```

```kotlin
// PaymentService.kt
@Retry(name = "pgRetry")
@CircuitBreaker(name = "pgCircuit", fallbackMethod = "paymentFallback")
@TimeLimiter(name = "pgTimeLimiter")
fun requestCardPayment(...): Payment {
    // ...
}
```

---

### 2. Actuator Health ì—”ë“œí¬ì¸íŠ¸ í™œì„±í™”

**ì¤‘ìš”ë„:** â­â­â­ (ê¶Œì¥)

**ë°°ê²½:**
- CircuitBreaker ìƒíƒœ ëª¨ë‹ˆí„°ë§ í•„ìš”

**êµ¬í˜„ ê°€ì´ë“œ:**

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,circuitbreakers,circuitbreakerevents
  endpoint:
    health:
      show-details: always
```

---

### 3. í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±

**ì¤‘ìš”ë„:** â­â­â­â­ (ì¤‘ìš”!)

**ë°°ê²½:**
- ê° ì‹œë‚˜ë¦¬ì˜¤ ê²€ì¦ í•„ìš”

**ì‘ì„±í•  í…ŒìŠ¤íŠ¸:**

#### 3-1. Payment ì—”í‹°í‹° ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```kotlin
// PaymentTest.kt
@Test
fun `ê²°ì œ ì„±ê³µ ìƒíƒœë¡œ ë³€ê²½`() {
    val payment = Payment.createCardPayment(...)
    payment.markAsSuccess()
    assertThat(payment.status).isEqualTo(PaymentStatus.SUCCESS)
}

@Test
fun `PENDING ìƒíƒœê°€ ì•„ë‹ ë•Œ ìƒíƒœ ë³€ê²½ ì‹œ ì˜ˆì™¸ ë°œìƒ`() {
    val payment = Payment.createCardPayment(...)
    payment.markAsSuccess()

    assertThrows<CoreException> {
        payment.markAsSuccess() // ì´ë¯¸ SUCCESS
    }
}
```

#### 3-2. PaymentCallbackService í†µí•© í…ŒìŠ¤íŠ¸
```kotlin
@Test
fun `ê²°ì œ ì„±ê³µ ì½œë°± ì²˜ë¦¬ ì‹œ ì¬ê³  ì°¨ê° ë° ì£¼ë¬¸ ì™„ë£Œ`() {
    // given
    val order = createOrder()
    val payment = createPayment(order.id)
    val callback = PaymentCallbackDto(
        transactionKey = payment.transactionKey!!,
        status = "SUCCESS",
        reason = null
    )

    // when
    paymentCallbackService.handlePaymentCallback(callback)

    // then
    val updatedPayment = paymentRepository.findById(payment.id)
    assertThat(updatedPayment.status).isEqualTo(PaymentStatus.SUCCESS)

    val updatedOrder = orderRepository.findById(order.id)
    assertThat(updatedOrder.status).isEqualTo(OrderStatus.COMPLETED)
}
```

---

## ğŸ“ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰ ê°€ì´ë“œ

### ì‹œë‚˜ë¦¬ì˜¤ 1: ì •ìƒ ê²°ì œ í”Œë¡œìš° âœ…

**ì¤€ë¹„:**
1. PG Simulator ì‹¤í–‰
2. commerce-api ì‹¤í–‰
3. DB ì´ˆê¸°í™”

**ì‹¤í–‰:**
```http
POST http://localhost:8080/api/v1/orders
X-USER-ID: test-user-123
Content-Type: application/json

{
  "items": [{"productId": 1, "quantity": 1}],
  "cardType": "SAMSUNG",
  "cardNo": "1234-5678-9814-1451"
}
```

**í™•ì¸:**
- [ ] Order status: PENDING â†’ COMPLETED
- [ ] Payment status: PENDING â†’ SUCCESS
- [ ] Product stock ì°¨ê°ë¨

---

### ì‹œë‚˜ë¦¬ì˜¤ 2: PG Timeout ë°œìƒ âš ï¸

**ì¤€ë¹„:**
1. PG Simulator ì¢…ë£Œ

**ì‹¤í–‰:**
```http
POST http://localhost:8080/api/v1/orders
...
```

**í™•ì¸:**
- [ ] Fallback ì‹¤í–‰ ë¡œê·¸
- [ ] Order status: FAILED
- [ ] Payment status: FAILED
- [ ] Product stock ë³€í™” ì—†ìŒ

---

### ì‹œë‚˜ë¦¬ì˜¤ 3: CircuitBreaker ë™ì‘ í™•ì¸ âš ï¸

**ì¤€ë¹„:**
1. PG Simulator ì¢…ë£Œ

**ì‹¤í–‰:**
- ì—°ì† 20íšŒ ì£¼ë¬¸ ìš”ì²­

**í™•ì¸:**
- [ ] CircuitBreaker OPEN ë¡œê·¸
- [ ] Actuator health: "state": "OPEN"
- [ ] ì¦‰ì‹œ Fallback ì‹¤í–‰ (PG í˜¸ì¶œ ì—†ìŒ)

---

### ì‹œë‚˜ë¦¬ì˜¤ 4: ì½œë°± ëˆ„ë½ ì‹œ ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ë³µêµ¬ ğŸš§ (ë¯¸êµ¬í˜„)

**ì¤€ë¹„:**
1. ì½œë°± URLì„ ì˜ëª»ëœ ì£¼ì†Œë¡œ ì„¤ì •
2. ì£¼ë¬¸ ìƒì„±
3. 10ë¶„ ëŒ€ê¸° (ë˜ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬ ì£¼ê¸° ì§§ê²Œ ì„¤ì •)

**í™•ì¸:**
- [ ] ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ ë¡œê·¸
- [ ] PG ìƒíƒœ ì¡°íšŒ ë¡œê·¸
- [ ] Order status: PENDING â†’ COMPLETED
- [ ] Payment status: PENDING â†’ SUCCESS
- [ ] Product stock ì°¨ê°ë¨

---

## ğŸ¯ ìš°ì„ ìˆœìœ„ ì‘ì—… ìˆœì„œ

### 1ë‹¨ê³„: í•„ìˆ˜ ê¸°ëŠ¥ ì™„ì„± (ì˜¤ëŠ˜ ì¤‘!)
1. âœ… **ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ë³µêµ¬ ë¡œì§ êµ¬í˜„** (1-2ì‹œê°„)
   - `PaymentReconciliationScheduler` ìƒì„±
   - `@EnableScheduling` í™œì„±í™”
   - `OrderRepository` ë©”ì„œë“œ ì¶”ê°€

2. âœ… **ì¬ê³  ë¶€ì¡± ì‹œ PG ì·¨ì†Œ ìš”ì²­ êµ¬í˜„** (30ë¶„-1ì‹œê°„)
   - `PgSimulatorClient.cancelPayment()` ì¶”ê°€
   - `PaymentCallbackService` ìˆ˜ì •

3. âœ… **Order.memberId í™œìš© í™•ì¸** (10ë¶„)
   - Order í´ë˜ìŠ¤ í™•ì¸
   - userId ì „ë‹¬ ë¡œì§ ê²€ì¦

### 2ë‹¨ê³„: í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ (ë‚´ì¼)
4. ğŸ§ª **ì‹œë‚˜ë¦¬ì˜¤ 1-6 í…ŒìŠ¤íŠ¸** (2-3ì‹œê°„)
   - ì •ìƒ ê²°ì œ
   - PG Timeout
   - CircuitBreaker
   - ì½œë°± ëˆ„ë½ ë³µêµ¬
   - ê²°ì œ ì‹¤íŒ¨
   - ì¬ê³  ë¶€ì¡±

5. ğŸ“ **í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìº¡ì³ ë° ë¬¸ì„œí™”** (1-2ì‹œê°„)
   - ë¡œê·¸ ìŠ¤í¬ë¦°ìƒ·
   - DB ìƒíƒœ ë³€í™”
   - í”Œë¡œìš° ë‹¤ì´ì–´ê·¸ë¨

### 3ë‹¨ê³„: ì„ íƒ ê¸°ëŠ¥ (ì‹œê°„ ì—¬ìœ ì‹œ)
6. â­ **Actuator Health ì„¤ì •** (10ë¶„)
7. â­ **Retry ì •ì±… ì¶”ê°€** (30ë¶„)
8. ğŸ§ª **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±** (1-2ì‹œê°„)

---

## ğŸ“Œ ì£¼ì˜ì‚¬í•­ ë° íŒ

### ì£¼ì˜ì‚¬í•­

1. **ìŠ¤ì¼€ì¤„ëŸ¬ ì£¼ê¸° ì„¤ì •**
   - ì‹¤ì œ: 1ë¶„ (60000ms)
   - í…ŒìŠ¤íŠ¸: 10ì´ˆ (10000ms) ê¶Œì¥

2. **ë©±ë“±ì„± ë³´ì¥**
   - ì¤‘ë³µ ì½œë°± ì²˜ë¦¬ ê²€ì¦ í•„ìˆ˜
   - ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€

3. **íŠ¸ëœì­ì…˜ ë²”ìœ„**
   - `@Transactional` ì ì ˆíˆ ì‚¬ìš©
   - PG í˜¸ì¶œì€ íŠ¸ëœì­ì…˜ ë°–ì—ì„œ

4. **ë¡œê¹…**
   - ëª¨ë“  ì£¼ìš” í”Œë¡œìš°ì— ë¡œê·¸ ì¶”ê°€
   - ERROR, WARN, INFO ë ˆë²¨ êµ¬ë¶„

### íŒ

1. **ë¹ ë¥¸ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì„¤ì •**
```yaml
# application-test.yml
resilience4j:
  circuitbreaker:
    instances:
      pgCircuit:
        minimum-number-of-calls: 5  # 20 â†’ 5ë¡œ ì¶•ì†Œ
        wait-duration-in-open-state: 3s  # 10s â†’ 3së¡œ ì¶•ì†Œ
```

2. **HTTP í…ŒìŠ¤íŠ¸ íŒŒì¼ í™œìš©**
   - `http/commerce-api/commerce-api.http` íŒŒì¼ì— ì‹œë‚˜ë¦¬ì˜¤ë³„ ìš”ì²­ ì €ì¥
   - IntelliJ HTTP Client ì‚¬ìš©

3. **ë¡œê·¸ í™•ì¸**
```bash
# commerce-api ë¡œê·¸
tail -f logs/application.log

# pg-simulator ë¡œê·¸
cd apps/pg-simulator && ./gradlew bootRun
```

---

## âœ… ìµœì¢… ì œì¶œ ì „ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì½”ë“œ êµ¬í˜„
- [ ] ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ë³µêµ¬ ë¡œì§ ì™„ì„±
- [ ] ì¬ê³  ë¶€ì¡± ì‹œ PG ì·¨ì†Œ ìš”ì²­ êµ¬í˜„
- [ ] Order.memberId í™œìš© ê²€ì¦

### í…ŒìŠ¤íŠ¸
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 1: ì •ìƒ ê²°ì œ ì„±ê³µ
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 2: PG Timeout í™•ì¸
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 3: CircuitBreaker ë™ì‘ í™•ì¸
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 4: ì½œë°± ëˆ„ë½ ë³µêµ¬ í™•ì¸
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 5: ê²°ì œ ì‹¤íŒ¨ í™•ì¸
- [ ] ì‹œë‚˜ë¦¬ì˜¤ 6: ì¬ê³  ë¶€ì¡± í™•ì¸

### ë¬¸ì„œí™”
- [ ] íŠ¸ëŸ¬ë¸”ìŠˆíŒ… 3ê°œ ì´ìƒ ì‘ì„±
- [ ] ì„¤ê³„ ê²°ì • ì´ìœ  ì‘ì„±
- [ ] Resilience4j ì„¤ì •ê°’ ê·¼ê±° ì‘ì„±
- [ ] íšŒê³  ì‘ì„±

### ìº¡ì³
- [ ] ì½”ë“œ ìŠ¤í¬ë¦°ìƒ· (20ê°œ)
- [ ] í…ŒìŠ¤íŠ¸ ë¡œê·¸ ìŠ¤í¬ë¦°ìƒ· (39ê°œ)
- [ ] DB ìƒíƒœ ë³€í™” ìŠ¤í¬ë¦°ìƒ·
- [ ] í”Œë¡œìš° ë‹¤ì´ì–´ê·¸ë¨

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸:** 2025-12-04
**ë‹¤ìŒ ì²´í¬ ì˜ˆì •:** ìŠ¤ì¼€ì¤„ëŸ¬ êµ¬í˜„ ì™„ë£Œ í›„
