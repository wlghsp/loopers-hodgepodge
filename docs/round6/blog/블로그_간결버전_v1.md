# PG 연동과 장애 대응

이번 주는 PG 연동이었다. API 호출하고 콜백 받으면 될 줄 알았는데, 생각보다 복잡했다.

외부 시스템은 언제든 장애가 날 수 있고, 네트워크는 불안정하다. 이를 어떻게 처리했는지 정리했다.

## 문제 발견

처음 구현한 코드:

```kotlin
fun processPayment(order: Order, cardNo: String): Payment {
    val pgResponse = pgClient.processPayment(...)

    // 문제: transactionKey만 받았는데 바로 재고 차감
    productService.decreaseStock(order)
    order.complete()

    return payment
}
```

**PG 서버가 느려서 3초 넘게 응답이 안오면?**
- 내 서버: 타임아웃으로 "결제 실패" 처리
- PG: 사실 성공했고, 5초 뒤에 콜백을 보냄
- 결과: 고객 카드는 결제됐는데 주문은 실패 상태

## PG는 비동기

PG는 비동기로 동작한다.

1. 내 서버 → PG: "결제 요청"
2. PG → 내 서버: "transactionKey 줄게, 나중에 콜백 보낼게"
3. PG는 따로 카드사랑 통신 (1~5초 걸림)
4. 완료되면 내 콜백 URL로 결과 전송

타임아웃 = 실패가 아니라 "아직 모름"

## 최종 결제 플로우

위 문제들을 해결한 후의 전체 플로우:

**1. 결제 요청**
```kotlin
@CircuitBreaker(name = "pgCircuit", fallbackMethod = "paymentFallback")
fun requestCardPayment(order: Order, cardNo: String): Payment {
    val pgResponse = pgClient.processPayment(...)

    // transactionKey 받음 → PENDING 상태로 저장
    return Payment.createCardPayment(
        transactionKey = pgResponse.transactionKey,
        status = PENDING  // 아직 성공 아님!
    )
}
```

**2. 콜백 처리**
```kotlin
fun processCallback(transactionKey: String, status: String) {
    val payment = paymentRepository.findByTransactionKey(transactionKey)

    if (payment.status != PENDING) return // 멱등성

    when (status) {
        "SUCCESS" -> {
            payment.markAsSuccess()
            productService.decreaseStock(order) // 여기서 재고 차감
            order.complete()
        }
        "FAILED" -> payment.markAsFailed(reason)
    }
}
```

**3. 타임아웃 발생 시**
- Fallback 실행 → PENDING으로 저장
- 스케줄러가 10분 후 PG에 직접 조회
- 또는 콜백이 늦게 오면 그때 처리

## 해결 방법

### 1. Circuit Breaker + Timeout

**Circuit Breaker의 3가지 상태:**

```
CLOSED (정상) → OPEN (차단) → HALF_OPEN (테스트) → CLOSED
```

- **CLOSED**: 정상 동작. 모든 요청 통과
- **OPEN**: 장애 감지. 10초간 PG 호출 차단, 즉시 Fallback 실행
- **HALF_OPEN**: 일부 요청만 통과시켜서 PG 복구 확인

Circuit Breaker에서 느린 호출을 판단하는 기준을 2초로 설정했다.


```yaml
resilience4j:
  circuitbreaker:
    instances:
      pgCircuit:
        slow-call-duration-threshold: 2s  # 2초 이상이면 "느린 호출"
        slow-call-rate-threshold: 50      # 느린 호출이 50% 이상이면
        failure-rate-threshold: 60        # 또는 실패율 60% 이상이면
        wait-duration-in-open-state: 10s  # Circuit OPEN (10초 대기)
```

**왜 이 값들인가?**

- **2초**: 정상 PG 응답 시간은 500ms~1초. 2초면 충분히 느린 것.
- **60%**: 절반 이상 실패하면 명백한 장애 상황.
- **10초**: PG가 재시작하거나 복구할 시간을 충분히 주기 위함.

중요한 건 **타임아웃 났을 때 주문을 실패 처리하면 안된다**는 것.

![Fallback 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/02-fallback-handling.png)

타임아웃 = "아직 모름"이니까 PENDING 상태로 남겨둔다.

### 2. Fallback으로 장애 격리

**Fallback이 없었다면?**

PG 장애 발생 시:
1. 결제 API 호출 → 2초 대기 → 타임아웃 예외
2. 예외가 컨트롤러까지 전파 → 500 에러
3. 사용자가 재시도 → 또 2초 대기 → 또 실패
4. 서버 스레드 100개 모두 PG 대기 중 → **전체 서버 먹통**

Fallback이 이를 즉시 차단:
- PG 타임아웃 → Fallback 실행 → PENDING 저장 → 즉시 응답

```kotlin
@CircuitBreaker(name = "pgCircuit", fallbackMethod = "paymentFallback")
fun requestCardPayment(...): Payment {
    val pgResponse = pgStrategy.requestPayment(...)
    // PG 응답받고 transactionKey 저장
}

// 타임아웃/장애 시 Fallback 실행
private fun paymentFallback(..., ex: Exception): Payment {
    logger.warn("결제 폴백 실행 - PENDING 상태로 저장")

    // PENDING으로 저장 (실패 아님!)
    return Payment.createPendingPayment(...)
}
```

Fallback + Circuit Breaker가 장애를 격리한다:
- Fallback: 주문을 PENDING으로 저장 (실패 아님!)
- Circuit Breaker: 실패율 60% 넘으면 10초간 요청 차단

### 3. 스케줄러로 콜백 누락 복구

콜백이 100% 오지 않을 수 있다:
- 네트워크 장애
- 서버 재시작 중
- 콜백 URL 오류

**스케줄러 동작:**

```kotlin
@Scheduled(fixedDelay = 60000) // 1분마다
fun recoverPendingPayments() {
    val pendingPayments = paymentRepository.findPendingPayments(10분 전)

    pendingPayments.forEach { payment ->
        // PG에 직접 상태 조회
        val status = pgClient.getPaymentStatus(payment.transactionKey)
        payment.updateStatus(status)
    }
}
```

![스케줄러 구현](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/04-scheduler.png)

10분 이상 PENDING인 주문을 1분마다 체크하여 복구한다.

## 테스트 결과

### 정상 케이스

PG가 정상 동작할 때:

1. 결제 요청 → PG 응답 (transactionKey 발급)
2. PENDING 상태로 저장
3. 콜백 수신 → SUCCESS로 변경, 재고 차감

![정상 결제 API](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/07-normal-payment-api.png)

로그에서 확인:
- PG 응답 수신
- transactionKey 저장
- 콜백 처리 완료

![정상 결제 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/08-normal-payment-log.png)

### PG 장애 시 Fallback

PG가 2초 이상 응답이 없을 때:

1. Timeout 발생
2. **Fallback 실행** → PENDING으로 저장 (FAILED 아님!)
3. 사용자에게는 결제 진행 중 안내

![PG 장애 API 응답](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/09-timeout-api.png)

로그 확인:
- "결제 폴백 실행 - PENDING 상태로 저장" 메시지
- 예외를 던지지 않고 PENDING Payment 반환

![Fallback 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/10-timeout-log.png)

### 스케줄러 복구

10분 이상 PENDING인 주문을 스케줄러가 복구:

1. 스케줄러가 1분마다 PENDING 주문 조회
2. PG에 직접 상태 확인
3. 성공/실패 상태로 업데이트

로그 확인:
- "Payment recovery started" 메시지
- PG 상태 조회 후 업데이트 완료

![스케줄러 복구 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/11-scheduler-recovery.png)

### Circuit Breaker OPEN

실패율 60% 이상 or 느린 호출 50% 이상이면 Circuit OPEN:

**OPEN이 되는 조건:**
- 최근 30초 동안 최소 20개 호출
- 실패율 60% 이상 또는 느린 호출(2초 이상) 50% 이상

**OPEN 상태에서:**
- PG 호출하지 않고 즉시 Fallback 실행
- 10초간 대기 후 HALF_OPEN으로 전환
- 일부 요청으로 PG 복구 확인

로그 확인:
- Circuit Breaker OPEN 상태 전환
- 즉시 Fallback 실행 (2초 대기 없음)

![Circuit Breaker OPEN](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/12-circuit-breaker-open.png)

## 구현 중 삽질했던 것들

### 1. 재고 차감 타이밍

처음엔 PG 요청 보내고 바로 재고 차감했다. 하지만 이 시점엔 transactionKey만 받은 것이지 실제 결제 성공은 아니다.

콜백 받고나서 재고 차감하도록 수정.

![콜백 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/05-callback-handling.png)

### 2. Fallback에서 FAILED로 저장

타임아웃 발생 시 Fallback에서 주문을 FAILED로 저장했었다.

문제: 나중에 콜백이 와도 이미 FAILED 상태라 복구가 불가능.

→ **PENDING으로 저장**하도록 수정. 콜백이 오면 상태 업데이트 가능.

### 3. transactionKey 받자마자 SUCCESS 처리

PG에서 transactionKey를 받으면 바로 SUCCESS로 변경했었다.

문제: transactionKey는 "접수 완료"일 뿐, 실제 카드사 승인은 나중에 올 수 있음. 콜백에서 FAILED가 올 수도 있다.

→ **PENDING 유지**하고 콜백에서만 최종 상태 변경.

### 4. 멱등성 처리

PG가 콜백을 2번 보내는 경우가 있다. 네트워크 재시도나 PG 내부 로직으로 인해 발생한다.

**문제 시나리오:**
1. 첫 번째 콜백: PENDING → SUCCESS, 재고 차감
2. 두 번째 콜백: SUCCESS → SUCCESS 시도, 재고 또 차감?

**해결:**

```kotlin
fun processCallback(transactionKey: String, status: String) {
    val payment = paymentRepository.findByTransactionKey(transactionKey)

    if (payment.status != PaymentStatus.PENDING) {
        logger.warn("이미 처리된 결제: ${payment.id}")
        return // 무시
    }

    // PENDING일 때만 상태 변경
    payment.updateStatus(status)
}
```

![멱등성 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/06-idempotency.png)

## 정리

- **타임아웃 ≠ 실패**. "아직 모름" → PENDING 상태 유지
- **Circuit Breaker**: slow-call-duration-threshold로 느린 호출 감지
- **Fallback**: 장애 시 주문을 PENDING으로 저장 (실패 아님)
- **스케줄러**: 콜백 누락 시 PG에 직접 상태 조회
- **멱등성**: 중복 콜백 방어 (이미 처리된 결제 무시)


---

**작성일**: 2025-12-05
