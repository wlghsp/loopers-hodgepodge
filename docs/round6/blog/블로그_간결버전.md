# PG 연동과 장애 대응

이번 주는 PG 연동이었다. API 호출하고 콜백 받으면 될 줄 알았는데, 생각보다 복잡했다.

외부 시스템은 언제든 장애가 날 수 있고, 네트워크는 불안정하다. 이를 어떻게 처리했는지 정리했다.

## 문제 발견

처음 구현한 코드:

```kotlin
fun processPayment(order: Order, cardNo: String): Payment {
    val pgResponse = pgClient.processPayment(...)

    // 문제: transactionKey만 받았는데 바로 재고 차감
    productService.decreaseStock(order)
    order.complete()

    return payment
}
```

**PG 서버가 느려서 3초 넘게 응답이 안오면?**
- 내 서버: 타임아웃으로 "결제 실패" 처리
- PG: 사실 성공했고, 5초 뒤에 콜백을 보냄
- 결과: 고객 카드는 결제됐는데 주문은 실패 상태

## PG는 비동기

PG는 비동기로 동작한다.

1. 내 서버 → PG: "결제 요청"
2. PG → 내 서버: "transactionKey 줄게, 나중에 콜백 보낼게"
3. PG는 따로 카드사랑 통신 (1~5초 걸림)
4. 완료되면 내 콜백 URL로 결과 전송

타임아웃 = 실패가 아니라 "아직 모름"

## 해결 방법

### 1. Circuit Breaker + Timeout

Circuit Breaker에서 느린 호출을 판단하는 기준을 2초로 설정했다.

![Circuit Breaker 설정](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/03-circuit-breaker-config.png)

```yaml
resilience4j:
  circuitbreaker:
    instances:
      pgCircuit:
        slow-call-duration-threshold: 2s  # 2초 이상이면 "느린 호출"
        slow-call-rate-threshold: 50      # 느린 호출이 50% 이상이면
        failure-rate-threshold: 60        # 또는 실패율 60% 이상이면
        wait-duration-in-open-state: 10s  # Circuit OPEN (10초 대기)
```

중요한 건 **타임아웃 났을 때 주문을 실패 처리하면 안된다**는 것.

![Fallback 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/02-fallback-handling.png)

타임아웃 = "아직 모름"이니까 PENDING 상태로 남겨둔다.

### 2. Fallback으로 장애 격리

PG 장애 시 예외가 발생하면 Fallback 메서드가 실행된다.

문제 상황:
- PG 서버 다운
- 모든 결제 요청이 2초씩 대기 → 타임아웃
- 서버 스레드 고갈
- 상품 조회, 회원가입까지 느려짐

Fallback + Circuit Breaker가 이걸 막아준다:
- Fallback: 주문을 PENDING으로 저장 (실패 아님!)
- Circuit Breaker: 실패율 60% 넘으면 10초간 요청 차단

### 3. 스케줄러로 콜백 누락 복구

콜백이 100% 오지 않을 수 있다.
- 네트워크 장애
- 서버 재시작 중
- 콜백 URL 오류

일정 시간 지나도 PENDING이면 PG에 직접 상태 조회.

![스케줄러 구현](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/04-scheduler.png)

10분 이상 PENDING인 주문을 1분마다 체크한다.

## 구현 중 수정사항

### 재고 차감 타이밍

처음엔 PG 요청 보내고 바로 재고 차감했다. 하지만 이 시점엔 transactionKey만 받은 것이지 실제 결제 성공은 아니다.

콜백 받고나서 재고 차감하도록 수정.

![콜백 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/05-callback-handling.png)

### 멱등성 처리

PG가 콜백을 2번 보내는 경우가 있다.

![멱등성 처리](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/06-idempotency.png)

이미 처리된 결제는 무시하도록 처리.

## 테스트 결과

### 정상 케이스

![정상 결제 API](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/07-normal-payment-api.png)

![정상 결제 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/08-normal-payment-log.png)

### PG 장애 시 Fallback

![PG 장애 API 응답](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/09-timeout-api.png)

![Fallback 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/10-timeout-log.png)

### 스케줄러 복구

![스케줄러 복구 로그](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/11-scheduler-recovery.png)

### Circuit Breaker

![Circuit Breaker OPEN](https://raw.githubusercontent.com/wlghsp/loopers-hodgepodge/master/docs/round6/blog/images/12-circuit-breaker-open.png)

## 정리

- **타임아웃 ≠ 실패**. "아직 모름" → PENDING 상태 유지
- **Circuit Breaker**: slow-call-duration-threshold로 느린 호출 감지
- **Fallback**: 장애 시 주문을 PENDING으로 저장 (실패 아님)
- **스케줄러**: 콜백 누락 시 PG에 직접 상태 조회
- **멱등성**: 중복 콜백 방어 (이미 처리된 결제 무시)


---

**작성일**: 2025-12-05
