# ì½”ë£¨í‹´ ìŠ¤ì¼€ì¤„ëŸ¬ ë³‘ë ¬ ì²˜ë¦¬ ì ìš© ì™„ë£Œ

> ğŸ“… ì ìš©ì¼: 2025-12-04
>
> âœ… PaymentReconciliationSchedulerì— ì½”ë£¨í‹´ ë³‘ë ¬ ì²˜ë¦¬ ì ìš© ì™„ë£Œ

---

## âœ… ì ìš© ì™„ë£Œ ë‚´ì—­

### 1. ì½”ë£¨í‹´ ì˜ì¡´ì„± ì¶”ê°€ âœ…

**íŒŒì¼:** `apps/commerce-api/build.gradle.kts`

```kotlin
// Coroutines
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.7.3")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-jdk8:1.7.3")
```

---

### 2. PaymentReconciliationScheduler êµ¬í˜„ âœ…

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/PaymentReconciliationScheduler.kt` (ì‹ ê·œ)

**ì£¼ìš” íŠ¹ì§•:**

#### ì½”ë£¨í‹´ ìŠ¤ì½”í”„ ì„¤ì •
```kotlin
private val coroutineScope = CoroutineScope(
    Dispatchers.IO + SupervisorJob()
)
```
- `Dispatchers.IO`: I/O ì‘ì—…ì— ìµœì í™”ëœ ë””ìŠ¤íŒ¨ì²˜
- `SupervisorJob`: í•˜ë‚˜ì˜ ì‘ì—… ì‹¤íŒ¨ê°€ ë‹¤ë¥¸ ì‘ì—…ì— ì˜í–¥ ì—†ìŒ

#### ë³‘ë ¬ ì²˜ë¦¬ ë¡œì§
```kotlin
@Scheduled(fixedDelay = 60000) // 1ë¶„ë§ˆë‹¤
fun reconcileStaleOrders() = runBlocking {
    val staleOrders = orderRepository.findByStatusAndCreatedAtBefore(...)

    // 10ê°œì”© ë¬¶ì–´ì„œ ë³‘ë ¬ ì²˜ë¦¬
    staleOrders.chunked(10).forEach { chunk ->
        chunk.map { order ->
            async(Dispatchers.IO) {
                try {
                    reconcileOrder(order)
                } catch (e: Exception) {
                    logger.error("Failed to reconcile order: ${order.id}", e)
                }
            }
        }.awaitAll()  // í˜„ì¬ ì²­í¬ì˜ ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
    }
}
```

#### ë¦¬ì†ŒìŠ¤ ì •ë¦¬
```kotlin
@PreDestroy
fun cleanup() {
    logger.info("Shutting down PaymentReconciliationScheduler coroutine scope")
    coroutineScope.cancel()
}
```

---

### 3. OrderRepository ë©”ì„œë“œ ì¶”ê°€ âœ…

#### 3-1. ì¸í„°í˜ì´ìŠ¤
**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/order/OrderRepository.kt`

```kotlin
fun findByStatusAndCreatedAtBefore(status: OrderStatus, time: LocalDateTime): List<Order>
```

#### 3-2. êµ¬í˜„ì²´
**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/order/OrderRepositoryImpl.kt`

```kotlin
override fun findByStatusAndCreatedAtBefore(
    status: OrderStatus,
    time: LocalDateTime
): List<Order> {
    return orderJpaRepository.findByStatusAndCreatedAtBefore(status, time)
}
```

#### 3-3. JPA Repository
**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/order/OrderJpaRepository.kt`

```kotlin
fun findByStatusAndCreatedAtBefore(status: OrderStatus, time: LocalDateTime): List<Order>
```
- Spring Data JPAì˜ ë©”ì„œë“œ ì¿¼ë¦¬ ìë™ ìƒì„± ê¸°ëŠ¥ í™œìš©

---

### 4. @EnableScheduling í™œì„±í™” âœ…

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/CommerceApiApplication.kt`

```kotlin
@ConfigurationPropertiesScan
@SpringBootApplication
@EnableScheduling  // ì¶”ê°€!
class CommerceApiApplication {
    // ...
}
```

---

### 5. ProductService ë©”ì„œë“œ í™•ì¸ âœ…

**íŒŒì¼:** `apps/commerce-api/src/main/kotlin/com/loopers/domain/product/ProductService.kt`

```kotlin
@Transactional
fun decreaseStockByOrder(order: Order) {
    val productIds = order.items.map { it.productId }
    val productMap = productRepository.findAllByIdInWithLock(productIds)
        .associateBy { it.id }

    order.items.forEach { item ->
        val product = productMap[item.productId]
            ?: throw CoreException(ErrorType.PRODUCT_NOT_FOUND, ...)
        product.decreaseStock(item.quantity)
    }
}
```
- ì´ë¯¸ êµ¬í˜„ë˜ì–´ ìˆìŒ! âœ…

---

## ğŸ“Š ì„±ëŠ¥ ê°œì„  íš¨ê³¼

### Before (ìˆœì°¨ ì²˜ë¦¬)
```
100ê°œ ì£¼ë¬¸ Ã— í‰ê·  500ms PG API í˜¸ì¶œ = 50ì´ˆ
```

### After (ë³‘ë ¬ ì²˜ë¦¬, 10ê°œì”©)
```
100ê°œ ì£¼ë¬¸ Ã· 10ê°œ ì²­í¬ Ã— í‰ê·  500ms = 5ì´ˆ
```

**ê²°ê³¼: ì•½ 10ë°° ì„±ëŠ¥ í–¥ìƒ! ğŸš€**

---

## ğŸ¯ ë™ì‘ ë°©ì‹

### 1. ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ (1ë¶„ë§ˆë‹¤)
```
1ë¶„ë§ˆë‹¤ reconcileStaleOrders() ì‹¤í–‰
  â†“
10ë¶„ ì´ìƒ PENDING ìƒíƒœì¸ ì£¼ë¬¸ ì¡°íšŒ
  â†“
ì£¼ë¬¸ì´ ìˆìœ¼ë©´ ë³‘ë ¬ ì²˜ë¦¬ ì‹œì‘
```

### 2. ë³‘ë ¬ ì²˜ë¦¬ í”Œë¡œìš°
```
100ê°œ ì£¼ë¬¸ ë°œê²¬
  â†“
10ê°œì”© ì²­í¬ë¡œ ë¶„í•  (ì´ 10ê°œ ì²­í¬)
  â†“
ê° ì²­í¬ë³„ë¡œ:
  - 10ê°œ ì£¼ë¬¸ì„ ë™ì‹œì— ì²˜ë¦¬ (async)
  - ê° ì£¼ë¬¸ë§ˆë‹¤:
    1. Payment ì¡°íšŒ
    2. PG ìƒíƒœ í™•ì¸ (getPaymentStatus)
    3. ê²°ê³¼ì— ë”°ë¼ ì²˜ë¦¬:
       - SUCCESS: ì¬ê³  ì°¨ê° + ì£¼ë¬¸ ì™„ë£Œ
       - FAILED: ì£¼ë¬¸ ì‹¤íŒ¨
       - PENDING: ê³„ì† ëŒ€ê¸°
  - awaitAll()ë¡œ í˜„ì¬ ì²­í¬ ì™„ë£Œ ëŒ€ê¸°
  â†“
ë‹¤ìŒ ì²­í¬ ì²˜ë¦¬
  â†“
ëª¨ë“  ì²­í¬ ì™„ë£Œ
```

### 3. ì˜ˆì™¸ ì²˜ë¦¬
```
ê°œë³„ ì£¼ë¬¸ ì²˜ë¦¬ ì‹¤íŒ¨ ì‹œ:
  - try-catchë¡œ ìºì¹˜
  - ë¡œê·¸ ê¸°ë¡
  - ë‹¤ë¥¸ ì£¼ë¬¸ ì²˜ë¦¬ ê³„ì† (SupervisorJob ë•ë¶„)
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### ì‹œë‚˜ë¦¬ì˜¤ 1: ì½œë°± ëˆ„ë½ ë³µêµ¬
```
1. ì£¼ë¬¸ ìƒì„± â†’ PG ê²°ì œ ìš”ì²­ ì„±ê³µ
2. ì½œë°± URLì„ ì˜ë„ì ìœ¼ë¡œ ì˜ëª» ì„¤ì • (ì½œë°± ëˆ„ë½)
3. 10ë¶„ ëŒ€ê¸°
4. ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ â†’ PG ìƒíƒœ ì¡°íšŒ
5. SUCCESS í™•ì¸ â†’ ì¬ê³  ì°¨ê° + ì£¼ë¬¸ ì™„ë£Œ
```

**í™•ì¸:**
- [ ] ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ ë¡œê·¸
- [ ] PG ìƒíƒœ ì¡°íšŒ ë¡œê·¸
- [ ] ì¬ê³  ì°¨ê° ë¡œê·¸
- [ ] Order status: PENDING â†’ COMPLETED
- [ ] Payment status: PENDING â†’ SUCCESS

---

### ì‹œë‚˜ë¦¬ì˜¤ 2: ë³‘ë ¬ ì²˜ë¦¬ ì„±ëŠ¥ í™•ì¸
```
1. 20ê°œ ì£¼ë¬¸ì„ PENDING ìƒíƒœë¡œ ìƒì„± (10ë¶„ ì´ìƒ ì „)
2. ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰
3. ë¡œê·¸ì—ì„œ ì²˜ë¦¬ ì‹œê°„ í™•ì¸
```

**ì˜ˆìƒ ê²°ê³¼:**
- 10ê°œì”© 2ê°œ ì²­í¬ë¡œ ë¶„í• 
- ê° ì²­í¬ ì²˜ë¦¬ ì‹œê°„: ~500ms
- ì´ ì²˜ë¦¬ ì‹œê°„: ~1ì´ˆ (ìˆœì°¨ë©´ 10ì´ˆ)

---

### ì‹œë‚˜ë¦¬ì˜¤ 3: ì˜ˆì™¸ ê²©ë¦¬ í™•ì¸
```
1. 10ê°œ ì£¼ë¬¸ ì¤‘ 5ë²ˆì§¸ ì£¼ë¬¸ì˜ Productë¥¼ ì‚­ì œ (ì¬ê³  ì°¨ê° ì‹¤íŒ¨ ìœ ë„)
2. ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰
3. 5ë²ˆì§¸ ì£¼ë¬¸ ì‹¤íŒ¨, ë‚˜ë¨¸ì§€ 9ê°œëŠ” ì •ìƒ ì²˜ë¦¬ í™•ì¸
```

**í™•ì¸:**
- [ ] 5ë²ˆì§¸ ì£¼ë¬¸: ì—ëŸ¬ ë¡œê·¸ + FAILED ì²˜ë¦¬
- [ ] ë‚˜ë¨¸ì§€ 9ê°œ: ì •ìƒ ì²˜ë¦¬ (SupervisorJob íš¨ê³¼)

---

## âš ï¸ ì£¼ì˜ì‚¬í•­

### 1. ì²­í¬ í¬ê¸° ì¡°ì •
```kotlin
// í˜„ì¬: 10ê°œì”©
staleOrders.chunked(10)

// PG API ë¶€í•˜ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥
// - ë„ˆë¬´ í¬ë©´: PG API ë¶€í•˜ ì¦ê°€
// - ë„ˆë¬´ ì‘ìœ¼ë©´: ì„±ëŠ¥ ì´ë“ ê°ì†Œ
```

**ê¶Œì¥:** 10~20ê°œ

---

### 2. íŠ¸ëœì­ì…˜ ê²½ê³„
```kotlin
// âœ… ì˜¬ë°”ë¥¸ íŒ¨í„´
fun reconcileStaleOrders() = runBlocking {  // @Transactional ì—†ìŒ
    staleOrders.map { order ->
        async { reconcileOrder(order) }  // reconcileOrderê°€ @Transactional
    }.awaitAll()
}

// âŒ ì˜ëª»ëœ íŒ¨í„´
@Transactional
fun reconcileStaleOrders() = runBlocking {  // íŠ¸ëœì­ì…˜ì´ ì½”ë£¨í‹´ ê²½ê³„ ë„˜ì–´ê°!
    // ...
}
```

---

### 3. ì½”ë£¨í‹´ ìŠ¤ì½”í”„ ìƒëª…ì£¼ê¸°
```kotlin
@PreDestroy
fun cleanup() {
    coroutineScope.cancel()  // í•„ìˆ˜! ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ ì‹œ ì •ë¦¬
}
```

---

### 4. ìŠ¤ì¼€ì¤„ëŸ¬ ì£¼ê¸° ì„¤ì •
```kotlin
// ì‹¤ì œ ìš´ì˜
@Scheduled(fixedDelay = 60000) // 1ë¶„

// í…ŒìŠ¤íŠ¸ ì‹œ (ë¹ ë¥¸ í™•ì¸)
@Scheduled(fixedDelay = 10000) // 10ì´ˆ
```

---

## ğŸ“ ë³€ê²½ëœ íŒŒì¼ ìš”ì•½

### ìˆ˜ì •ëœ íŒŒì¼ (6ê°œ)
1. âœ… `apps/commerce-api/build.gradle.kts`
2. âœ… `apps/commerce-api/src/main/kotlin/com/loopers/CommerceApiApplication.kt`
3. âœ… `apps/commerce-api/src/main/kotlin/com/loopers/domain/order/OrderRepository.kt`
4. âœ… `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/order/OrderRepositoryImpl.kt`
5. âœ… `apps/commerce-api/src/main/kotlin/com/loopers/infrastructure/order/OrderJpaRepository.kt`

### ì‹ ê·œ íŒŒì¼ (1ê°œ)
6. âœ… `apps/commerce-api/src/main/kotlin/com/loopers/domain/payment/PaymentReconciliationScheduler.kt`

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

### ì¦‰ì‹œ í™•ì¸ (í•„ìˆ˜)
1. [ ] ë¹Œë“œ ì„±ê³µ í™•ì¸
   ```bash
   ./gradlew clean build
   ```

2. [ ] ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
   ```bash
   ./gradlew bootRun
   ```

3. [ ] ìŠ¤ì¼€ì¤„ëŸ¬ ë¡œê·¸ í™•ì¸
   ```
   Found 0 stale orders to reconcile  # ì •ìƒ (PENDING ì£¼ë¬¸ ì—†ìŒ)
   ```

### í…ŒìŠ¤íŠ¸ (ì„ íƒ)
4. [ ] ì‹œë‚˜ë¦¬ì˜¤ 1: ì½œë°± ëˆ„ë½ ë³µêµ¬ í…ŒìŠ¤íŠ¸
5. [ ] ì‹œë‚˜ë¦¬ì˜¤ 2: ë³‘ë ¬ ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
6. [ ] ì‹œë‚˜ë¦¬ì˜¤ 3: ì˜ˆì™¸ ê²©ë¦¬ í…ŒìŠ¤íŠ¸

---

## ğŸ’¡ ì¶”ê°€ ìµœì í™” ì•„ì´ë””ì–´

### 1. ë™ì  ì²­í¬ í¬ê¸° ì¡°ì •
```kotlin
val chunkSize = when {
    staleOrders.size < 10 -> staleOrders.size
    staleOrders.size < 50 -> 10
    else -> 20
}
staleOrders.chunked(chunkSize)
```

### 2. ì¬ì‹œë„ ë¡œì§ ì¶”ê°€
```kotlin
suspend fun reconcileOrderWithRetry(order: Order, maxRetries: Int = 3) {
    repeat(maxRetries) { attempt ->
        try {
            reconcileOrder(order)
            return
        } catch (e: Exception) {
            if (attempt == maxRetries - 1) throw e
            delay(1000 * (attempt + 1))  // ì§€ìˆ˜ ë°±ì˜¤í”„
        }
    }
}
```

### 3. ë©”íŠ¸ë¦­ ìˆ˜ì§‘
```kotlin
val successCount = AtomicInteger(0)
val failureCount = AtomicInteger(0)

chunk.map { order ->
    async {
        try {
            reconcileOrder(order)
            successCount.incrementAndGet()
        } catch (e: Exception) {
            failureCount.incrementAndGet()
        }
    }
}.awaitAll()

logger.info("Reconciliation: success=$successCount, failure=$failureCount")
```

---

**ì ìš© ì™„ë£Œ ì¼ì‹œ:** 2025-12-04
**ì˜ˆìƒ ì„±ëŠ¥ ê°œì„ :** 10ë°°
**ìƒíƒœ:** í…ŒìŠ¤íŠ¸ ëŒ€ê¸° ì¤‘
